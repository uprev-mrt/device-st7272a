/**
  * @file st7272a.c
  * @author generated by mrt-device utility 
  * @link [https://github.com/uprev-mrt/mrtutils/wiki/mrt-device]
  * @brief Device driver for st7272a device
  *
  */

#include "st7272a.h"



/**
 * @brief initializes device
 * @param dev ptr to st7272a device
 * @return status 
 */
static mrt_status_t st7272a_init(st7272a_t* dev)
{   
    /* Initialize Register Descriptors */
    REG_INIT( dev->mDispCtrl , ST7272A_REG_DISP_CTRL_ADDR , uint8_t, REG_PERM_RW , 0x08  );
    REG_INIT( dev->mContrast , ST7272A_REG_CONTRAST_ADDR , uint8_t, REG_PERM_RW , 0x40  );
    REG_INIT( dev->mSubContrastR , ST7272A_REG_SUB_CONTRAST_R_ADDR , uint8_t, REG_PERM_RW , 0x40  );
    REG_INIT( dev->mSubContrastB , ST7272A_REG_SUB_CONTRAST_B_ADDR , uint8_t, REG_PERM_RW , 0x40  );
    REG_INIT( dev->mBrightness , ST7272A_REG_BRIGHTNESS_ADDR , uint8_t, REG_PERM_RW , 0x40  );
    REG_INIT( dev->mSubBrightnessR , ST7272A_REG_SUB_BRIGHTNESS_R_ADDR , uint8_t, REG_PERM_RW , 0x40  );
    REG_INIT( dev->mSubBrightnessB , ST7272A_REG_SUB_BRIGHTNESS_B_ADDR , uint8_t, REG_PERM_RW , 0x40  );
    REG_INIT( dev->mHBlanking , ST7272A_REG_H_BLANKING_ADDR , uint8_t, REG_PERM_RW , 0x40  );
    REG_INIT( dev->mVBlanking , ST7272A_REG_V_BLANKING_ADDR , uint8_t, REG_PERM_RW , 0x40  );
    REG_INIT( dev->mDisplayMode , ST7272A_REG_DISPLAY_MODE_ADDR , uint8_t, REG_PERM_RW , 0x6D  );
    REG_INIT( dev->mBistFnctnSetting , ST7272A_REG_BIST_FNCTN_SETTING_ADDR , uint8_t, REG_PERM_RW , 0x38  );


    /*user-block-init-start*/
    /*user-block-init-end*/

    return MRT_STATUS_OK;
}


mrt_status_t st7272a_init_i2c(st7272a_t* dev, mrt_i2c_handle_t i2c)
{
    mrt_status_t status;

    status = init_i2c_register_device(&dev->mRegDev, i2c, ST7272A_I2C_ADDRESS, ST7272A_REG_ADDR_SIZE );

    st7272a_init(dev);


    /*user-block-init-i2c-start*/
    /*user-block-init-i2c-end*/
    
    return status;
}
mrt_status_t st7272a_init_spi(st7272a_t* dev, mrt_spi_handle_t spi, mrt_gpio_t chipSelect)
{
    mrt_status_t status;

    status = init_spi_register_device(&dev->mRegDev, spi, chipSelect, ST7272A_REG_ADDR_SIZE );

    st7272a_init(dev);

    /*user-block-spi-start*/

    //Use custom read function because we have to set the 'R' read bit
    dev->mRegDev.fRead = &st272a_read_spi; 

    /*user-block-spi-end*/

    return status;
}

mrt_status_t st7272a_test(st7272a_t* dev)
{
    mrt_status_t status = MRT_STATUS_ERROR;
    /*user-block-test-start*/

    if( st272a_read_reg(dev, &dev->mBistFnctnSetting) == ST272A_BIST_FNCTN_SETTING_DEFAULT)
    {
        status = MRT_STATUS_OK;
    }

    /*user-block-test-end*/
    return status;
}


/*user-block-bottom-start*/


mrt_status_t st272a_read_spi(mrt_regdev_t* dev, uint32_t addr, uint8_t* data, int len)
{
  mrt_status_t status;

  MRT_GPIO_WRITE(dev->mChipSelect, MRT_LOW);

  addr |= 0x80;

  //send address
  status = MRT_SPI_TRANSMIT(dev->mSpiHandle, &addr, dev->mMemAddrSize, dev->mTimeout );

  MRT_DELAY_MS(1);
  //read data
  status = MRT_SPI_RECIEVE(dev->mSpiHandle, data, len, dev->mTimeout);

  MRT_GPIO_WRITE(dev->mChipSelect, MRT_HIGH);

  

  return status;
}

/*user-block-bottom-end*/
